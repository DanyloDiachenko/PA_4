# Проста СУБД із Щільним Індексом та Областю Переповнення

Цей проєкт реалізує просту Систему Керування Базами Даних (СУБД) із Графічним Інтерфейсом Користувача (GUI). Вона використовує **Щільний Індекс** у поєднанні з **Областю Переповнення** для керування даними, що зберігаються у фізичних файлах.

## Функціональність
- **Фізичне Зберігання Файлів**: Дані зберігаються у `db/main.db` (відсортовані) та `db/overflow.db` (невідсортовані).
- **Щільний Індекс**: Індекс у пам'яті (зберігається у `db/index.json`) відображає ключі на розташування у файлах.
- **CRUD Операції**: Пошук, Додавання, Редагування, Видалення.
- **Візуалізація**: Перегляд структури Індексу та Файлів даних.
- **Експерименти**: Вбудований інструмент тестування для перевірки швидкодії пошуку.

## Алгоритми та Складність

### Алгоритм Бінарного Пошуку
Використовується для знаходження ключа в масиві Індексу, що знаходиться в пам'яті.

**Псевдокод**:
```text
function BinarySearch(Index, key):
    left = 0
    right = length(Index) - 1
    
    while left <= right:
        mid = floor((left + right) / 2)
        if Index[mid].key == key:
            return Index[mid]
        else if Index[mid].key < key:
            left = mid + 1
        else:
            right = mid - 1
            
    return null
```
**Складність**: $O(\log N)$

Бінарний пошук є високоефективним алгоритмом для знаходження елемента у відсортованому масиві, оскільки він ділить область пошуку навпіл на кожному кроці. Початкова складність алгоритму становить $O(\log N)$, де $N$ — це кількість записів у індексному масиві. Це означає, що навіть при значному збільшенні кількості даних, час пошуку зростає дуже повільно, що робить його ідеальним для великих баз даних. Наприклад, для пошуку серед 10 000 записів знадобиться не більше 14 порівнянь ($\log_2 10000 \approx 13.29$). Кожна ітерація циклу зменшує діапазон можливих значень вдвічі, відкидаючи половину масиву, де шуканий елемент точно не може знаходитись. Така логарифмічна залежність забезпечує стабільну та швидку роботу системи навіть при мільйонах записів, на відміну від лінійного пошуку $O(N)$.

### 1. Пошук (Search)
**Псевдокод**:
```text
function Search(key):
    indexEntry = BinarySearch(Index, key)
    if indexEntry is null:
        return Not Found
    
    file = Open(indexEntry.file)
    Seek(file, indexEntry.offset)
    record = Read(file, RecordSize)
    return record
```
**Складність**: $O(\log N)$
- Бінарний пошук по індексу займає логарифмічний час.
- Доступ до файлу займає $O(1)$ (Прямий Доступ).

### 2. Додавання (Add)
**Псевдокод**:
```text
function Add(key, value):
    if Search(key) is found:
        Error "Key exists"
    
    record = CreateRecord(key, value)
    offset = FileSize(OverflowFile)
    Append(OverflowFile, record)
    
    newEntry = { key, file: 'overflow', offset }
    InsertIntoSortedArray(Index, newEntry)
    SaveIndex()
```
**Складність**: $O(N)$
- Додавання в кінець файлу займає $O(1)$.
- Вставка у відсортований масив Індексу вимагає зсуву елементів, що займає $O(N)$.

### 3. Видалення (Delete)
**Псевдокод**:
```text
function Delete(key):
    indexPos = BinarySearchIndex(Index, key)
    if indexPos == -1:
        Error "Not Found"
    
    RemoveAt(Index, indexPos)
    SaveIndex()
```
**Складність**: $O(N)$
- Видалення з масиву вимагає зсуву елементів, що займає $O(N)$.
- Дані залишаються у файлі (помічаються як видалені неявно через відсутність в індексі).

### 4. Редагування (Edit)
**Псевдокод**:
```text
function Edit(key, newValue):
    indexEntry = BinarySearch(Index, key)
    if indexEntry is null:
        Error "Not Found"
    
    record = CreateRecord(key, newValue)
    file = Open(indexEntry.file)
    Write(file, record, indexEntry.offset)
```
**Складність**: $O(\log N)$
- Пошук займає $O(\log N)$.
- Перезапис запису займає $O(1)$.

## Експериментальні Результати

**Налаштування**:
- База даних заповнена **10,000** випадковими унікальними записами.
- Записи відсортовані та збережені у `main.db`.
- Виконано **25** випадкових пошуків.

**Результати**:
- **Середня кількість порівнянь**: 12.0
- **Теоретичне очікування**: $\log_2(10000) \approx 13.29$.
- Експериментальний результат ідеально узгоджується з теоретичною складністю бінарного пошуку.

**Приклад Даних**:
| Ключ | Порівняння |
|-----|-------------|
| 22126 | 5 |
| 23484 | 13 |
| 2523 | 12 |
| ... | ... |

## Висновки
Реалізація успішно демонструє ефективність структури Щільного Індексу.
- **Операції Пошуку** є надзвичайно швидкими ($O(\log N)$) завдяки бінарному пошуку по індексу та прямому доступу до файлів.
- **Вставки** обробляються через Область Переповнення, уникаючи необхідності перезаписувати весь відсортований основний файл. Однак підтримка відсортованого індексу в пам'яті створює витрати $O(N)$, що є прийнятним для такого масштабу, але вимагало б B-дерев для більших систем.
- **Візуалізація** допомагає зрозуміти, як індекс відображає логічні ключі на фізичні зміщення у файлах.

## Як Запустити

1. **Встановити Залежності**:
   ```bash
   npm install
   ```

2. **Запустити Сервер**:
   ```bash
   npm start
   ```

3. **Відкрити GUI**:
   Відкрийте [http://localhost:3000](http://localhost:3000) у вашому браузері.

4. **Використання**:
   - Використовуйте панель **Operations** для керування записами.
   - Використовуйте панель **Experiments** для генерації даних та запуску тестів.
